A big thing that we wanted going into this project was a clean main.lua file, where only really essential calculations and functions were taking place. This played a big role in the amount of .lua files we decided to have, such as different files for all of our UI stages, enemies and weapons in their own folders, and separate assets and libs folders to separate our code from the other parts of the game. Another thing design-wise that we tried to do whenever we could is create tables using lua's automatic table-typed variables so that we could store and access mass amounts of data about a player, enemy, or weapon without having to worry about many individal variables. Similarly, the way that .draw works in Lua made it imperitive for us to be careful about how many times we were drawing each object to eliminate lag, which lead to the design choice of the sprites table to draw one image each frame as a whole instead of having to reset each image path upon drawing an object. 

For this game, we knew we wanted it to get progressivley harder and for enemies and the player to scale as time went on. Because of this, we gave the player and enemies a bunch of stats that could change over time. We used basic stats such as health, damage, speed, etc. But we also wanted the player to have to choose between certain upgrade paths each game, which is why we overhauled our upgrades to include a plethora of options such as different regen mechanics like heal on level up, passive, and lifesteal, different ways to do more damage such as more projectiles, straight damage, attack speed, critical strike chance, or range. Or the player can sometimes choose to go for something else like an XP percentage increase to keep up with the fact that each level takes more xp than the last. Overall, these design features were implemented in order to create a game where the player dies quickly on some runs and survives near infinitely on others, where both skill of the player and luck of upgrades play a part in how well the player does. We also wanted there to be some level of replayability, which is why we have different weapon choices so that players can test out and see what they like most. 

Another design choice we chose was to have inheritance to make it easy to create new enemy types. enemy.lua gave us an easy way to create new types of enemies with new stats and it would have some base functionality no matter what, and then all we had to do was draw the sprite for the new enemy and add any functions that we wanted for special enemy behavior in a new file. An example of this is the smokecloud that brown.lua (students from brown) produce or how dartmouth enemies wobble when they walk and throw a bottle. This type of design choice helped us have easy functions that could be used all over our codespace like damaging enemies by simply passing in the damage of the weapon, which used a collision detection created to check hitboxes between any 2 objects. Overall this allowed us to have functions that both of us (Levi and Colin, us partners working on the project) understood and could use without having to create new functions to do essentially the same thing. 